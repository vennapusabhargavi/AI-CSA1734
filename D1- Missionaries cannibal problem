from collections import deque

class State:
    def __init__(self, missionaries, cannibals, boat):
        self.missionaries = missionaries
        self.cannibals = cannibals
        self.boat = boat

    def __eq__(self, other):
        return self.missionaries == other.missionaries and \
               self.cannibals == other.cannibals and \
               self.boat == other.boat

    def __hash__(self):
        return hash((self.missionaries, self.cannibals, self.boat))

    def __str__(self):
        return f"({self.missionaries}, {self.cannibals}, {self.boat})"

def valid_state(state):
    if state.missionaries < 0 or state.missionaries > 3:
        return False
    if state.cannibals < 0 or state.cannibals > 3:
        return False
    return True

def is_goal(state):
    return state.missionaries == 0 and state.cannibals == 0 and state.boat == 0

def successors(state):
    children = []
    if state.boat == 1:
        for m in range(3):
            for c in range(3):
                if 1 <= m + c <= 2:
                    new_state = State(state.missionaries - m, state.cannibals - c, 0)
                    if valid_state(new_state):
                        children.append(new_state)
    else:
        for m in range(3):
            for c in range(3):
                if 1 <= m + c <= 2:
                    new_state = State(state.missionaries + m, state.cannibals + c, 1)
                    if valid_state(new_state):
                        children.append(new_state)
    return children

def bfs(start):
    frontier = deque([start])
    visited = set()
    visited.add(start)
    parent = {start: None}

    while frontier:
        state = frontier.popleft()
        if is_goal(state):
            path = []
            while state:
                path.append(state)
                state = parent[state]
            return path[::-1]
        
        for child in successors(state):
            if child not in visited:
                visited.add(child)
                parent[child] = state
                frontier.append(child)

    return None

def print_solution(path):
    for i, state in enumerate(path):
        print(f"Step {i}: {state}")

if __name__ == "__main__":
    initial_state = State(3, 3, 1)
    solution = bfs(initial_state)
    if solution:
        print("Solution found:")
        print_solution(solution)
    else:
        print("No solution found.")
